name: DevSecOps Pipeline para OWASP Juice Shop

# Define quando este workflow será acionado
on:
  push:
    branches:
      - develop # Branch principal do projeto OWASP Juice Shop
      - main # Caso o leitor use 'main' como branch principal em seu fork
      - master # Caso o leitor use 'master' como branch principal em seu fork
  pull_request:
    branches:
      - develop
      - main
      - master
  workflow_dispatch: # Permite o acionamento manual do workflow pela interface do GitHub

jobs:
  # =====================================================================================
  # ETAPA 1: LINTING E FORMATAÇÃO
  # Objetivo: Garantir que os arquivos de configuração da pipeline e scripts auxiliares
  # (se houver) sigam padrões de qualidade e formatação.
  # Para um projeto real, esta etapa seria expandida para incluir linters específicos
  # para o código da aplicação (ex: ESLint para JavaScript/Angular, linters para Node.js).
  # =====================================================================================
  lint-files:
    name: Linting de Arquivos da Pipeline (YAML)
    runs-on: ubuntu-latest # Define o tipo de máquina virtual para executar o job
    steps:
      # Passo 1.1: Baixar o código do repositório para o ambiente do runner
      - name: Checkout do código do repositório
        uses: actions/checkout@v4 # Action oficial do GitHub para checkout

      # Passo 1.2: Verificar a sintaxe e estilo dos arquivos YAML no diretório .github/workflows
      # Isso ajuda a pegar erros no próprio arquivo do workflow.
      - name: Lint dos arquivos YAML da pipeline
        uses: ibiqlik/action-yamllint@v3.1.1 # Action da comunidade para yamllint
        continue-on-error: true # Permite que o workflow continue mesmo se o linter encontrar avisos (para fins didáticos)
        with:
          file_or_dir: .github/workflows/ # Diretório a ser verificado
          config_file: .yamllint.yml # Opcional: Arquivo de configuração customizado para o yamllint (se você criou ele)

  # =====================================================================================
  # ETAPA 2: ANÁLISE ESTÁTICA DE SEGURANÇA DE APLICAÇÃO (SAST)
  # Objetivo: Analisar o código-fonte em busca de padrões de vulnerabilidades conhecidas
  # sem executar a aplicação.
  # Ferramentas: Semgrep e GitHub CodeQL
  # =====================================================================================
  sast-analysis:
    name: Análise Estática de Segurança (SAST com Semgrep e CodeQL)
    runs-on: ubuntu-latest
    permissions:
      actions: read
      contents: read
      security-events: write # Necessário para o CodeQL enviar resultados para a aba Security
    steps:
      # Passo 2.1: Baixar o código-fonte do OWASP Juice Shop
      # Usamos o repositório oficial para garantir que estamos analisando a versão correta.
      - name: Checkout do código do OWASP Juice Shop
        uses: actions/checkout@v4

      # --- SAST com Semgrep ---
      # Passo 2.2: Instalar a ferramenta Semgrep
      - name: Configurar Semgrep
        run: pip install semgrep # Instala Semgrep via pip

      # Passo 2.3: Executar o Semgrep com um conjunto de regras padrão (p/default)
      # O resultado é salvo no formato SARIF, um padrão para resultados de análise estática.
      # "|| true" garante que o workflow continue mesmo se o Semgrep encontrar vulnerabilidades (para fins didáticos).
      - name: Executar Semgrep
        run: semgrep scan --config "p/default" --sarif --output semgrep.sarif || true

      # Passo 2.4: Fazer upload do relatório SARIF do Semgrep como um artefato do workflow
      # Isso permite que você baixe e analise o relatório completo depois.
      - name: Upload do relatório SARIF do Semgrep (Artefato)
        uses: actions/upload-artifact@v4
        with:
          name: semgrep-results
          path: semgrep.sarif

      # Passo 2.5: Enviar o relatório SARIF do Semgrep para a aba "Security" -> "Code scanning alerts" do GitHub
      # "if: always()" garante que este passo execute mesmo se o anterior (execução do Semgrep) falhar (por ter encontrado vulnerabilidades).
      - name: Upload do resultado SARIF do Semgrep para GitHub Security
        if: always()
        uses: github/codeql-action/upload-sarif@v3
        with:
          sarif_file: semgrep.sarif
          category: semgrep-juiceshop # Categoria para agrupar os alertas no GitHub

      # --- SAST com GitHub CodeQL ---
      # O CodeQL é uma poderosa engine de análise semântica do GitHub.
      # Passo 2.6: Inicializar o CodeQL. Ele detecta a linguagem (Node.js/JavaScript para Juice Shop) e configura a análise.
      - name: Inicializar CodeQL
        uses: github/codeql-action/init@v3
        with:
          languages: javascript # Especificamos JavaScript/TypeScript para o Juice Shop

      # (Opcional) Se o projeto precisasse ser compilado (ex: Java, C#), o passo de build viria aqui.
      # Para o Juice Shop (Node.js), o CodeQL geralmente consegue analisar sem um passo de build explícito aqui.

      # Passo 2.7: Executar a análise do CodeQL
      - name: Executar Análise CodeQL
        uses: github/codeql-action/analyze@v3
        with:
          category: codeql-juiceshop # Categoria para os alertas do CodeQL

      # O CodeQL automaticamente faz o upload dos resultados para a aba Security se configurado corretamente.
      # O passo de upload-sarif para o CodeQL é implicitamente feito pela action 'analyze'.

  # =====================================================================================
  # ETAPA 3: ANÁLISE DE COMPOSIÇÃO DE SOFTWARE (SCA) E GERAÇÃO DE SBOM
  # Objetivo: Identificar componentes de terceiros (dependências) e suas vulnerabilidades
  # conhecidas. Também geraremos um Software Bill of Materials (SBOM).
  # Ferramentas: NPM Audit, OWASP Dependency-Check, cdxgen
  # =====================================================================================
  sca-analysis:
    name: Análise de Composição de Software (SCA) e Geração de SBOM
    runs-on: ubuntu-latest
    permissions:
      contents: read # Necessário para checkout e para Dependency-Check ler arquivos
      security-events: write # Necessário para Dependency-Check (via upload-sarif) enviar resultados para a aba Security
    steps:
      # Passo 3.1: Baixar o código-fonte do OWASP Juice Shop
      - name: Checkout do código do OWASP Juice Shop
        uses: actions/checkout@v4

      # Passo 3.2: Configurar o ambiente Node.js para instalar dependências
      - name: Configurar Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18' # Versão LTS compatível com o Juice Shop

      # Passo 3.3: Instalar as dependências do projeto.
      # Isso é crucial para que ferramentas de SCA possam identificar os pacotes e versões corretas.
      # O comando 'npm install' também gera/atualiza o 'package-lock.json', que é usado por muitas ferramentas SCA.
      - name: Instalar dependências (gera package-lock.json)
        run: |
           npm install --package-lock-only --ignore-scripts
           ls -la

      # --- SCA com NPM Audit ---
      # Passo 3.4: Executar 'npm audit' para encontrar vulnerabilidades nas dependências Node.js.
      # O resultado JSON é convertido para SARIF para integração com o GitHub Security.
      - name: Executar NPM Audit e gerar SARIF
        run: |
          npm audit --json > npm-audit-results.json || true # "|| true" para não falhar o build se encontrar vulnerabilidades
          # Instala a ferramenta de conversão npm-audit-sarif
          npm install -g npm-audit-sarif
          # Converte o JSON do npm audit para o formato SARIF
          npm-audit-sarif -o npm-audit.sarif npm-audit-results.json || echo "Falha ao converter npm audit para SARIF. O arquivo de resultados pode estar vazio ou malformado."

      # Passo 3.5: Fazer upload do relatório SARIF do NPM Audit como artefato.
      - name: Upload do relatório SARIF do NPM Audit (Artefato)
        uses: actions/upload-artifact@v4
        with:
          name: npm-audit-results # Nome do artefato
          path: npm-audit.sarif # Caminho para o arquivo a ser carregado

      # --- Geração de SBOM com cdxgen (CycloneDX) ---
      # Passo 3.6: Gerar o Software Bill of Materials (SBOM) no formato CycloneDX.
      # O SBOM é uma lista de todos os componentes de software, essencial para a segurança da cadeia de suprimentos.
      # Adicionamos --project-type nodejs para focar na análise das dependências Node.js.
      - name: Gerar SBOM com cdxgen
        run: |
          echo "Gerando SBOM para o projeto Node.js..."
          # Usamos 'npx' para executar a versão mais recente sem instalação global.
          # Especificamos o tipo de projeto e o arquivo de lockfile para maior precisão.
          # O output (-o) será bom.json.
          npm install -g @cyclonedx/cdxgen
          cdxgen -p . --project-type nodejs --output bom.json --spec-version 1.5 --no-github-workflow || echo "::warning::Falha ao gerar SBOM com cdxgen. Verifique os logs acima."
          # Verificamos se o bom.json foi criado. Se não, o step falhará.
          if [ ! -f bom.json ]; then
            echo "::error::Arquivo bom.json não foi gerado pelo cdxgen."
            exit 1
          fi
          echo "SBOM gerado com sucesso: bom.json"
          head -n 20 bom.json # Mostra as primeiras 20 linhas do SBOM
      
      # Passo 3.7: Fazer upload do SBOM gerado como artefato.
      - name: Upload do SBOM (bom.json) como Artefato
        uses: actions/upload-artifact@v4
        with:
          name: sbom-cyclonedx
          path: bom.json

      # --- SCA com OWASP Dependency-Check ---
      # Passo 3.8: Configurar Java, pois Dependency-Check é uma ferramenta Java.
      - name: Configurar Java para Dependency-Check
        uses: actions/setup-java@v4
        with:
          distribution: 'temurin' # Distribuição recomendada do OpenJDK
          java-version: '11' # Versão compatível com Dependency-Check (verificar documentação para a mais recente)

      # Passo 3.9: Baixar a ferramenta OWASP Dependency-Check CLI.
      - name: Download OWASP Dependency-Check
        run: |
          DC_VERSION="12.1.0" # VERIFIQUE SEMPRE A ÚLTIMA VERSÃO ESTÁVEL NO GITHUB DO PROJETO!
          wget https://github.com/jeremylong/DependencyCheck/releases/download/v${DC_VERSION}/dependency-check-${DC_VERSION}-release.zip
          unzip dependency-check-${DC_VERSION}-release.zip

      # Passo 3.10: Executar o OWASP Dependency-Check.
      # Requer uma NVD_API_KEY (configurada como secret no GitHub) para buscar dados de vulnerabilidades do NVD.
      # "--failOnCVSS 7" faria o step falhar se encontrasse CVEs com score >= 7. Adicionamos "|| true" para fins didáticos.
      - name: Executar OWASP Dependency-Check
        run: |
          ./dependency-check/bin/dependency-check.sh \
            --scan . \
            --project "OWASP-Juice-Shop" \
            --format SARIF \
            --out dependency-check-results.sarif \
            --enableExperimental \
            --nvdApiKey ${{ secrets.NVD_API_KEY }} \
            --failOnCVSS 7 || true # Continua para upload mesmo se falhar
          # Adiciona uma verificação explícita da existência do arquivo
          if [ ! -f dependency-check-results.sarif ]; then
            echo "::error::Arquivo dependency-check-results.sarif não foi gerado."
            ls -la # Lista os arquivos no diretório atual para depuração
            exit 1
          fi

      # Passo 3.11: Fazer upload do relatório SARIF do Dependency-Check como artefato.
      - name: Upload do relatório SARIF do Dependency-Check (Artefato)
        uses: actions/upload-artifact@v4
        with:
          name: Dependency-Check-results
          path: dependency-check-results.sarif

      # Passo 3.12: Enviar o relatório SARIF do Dependency-Check para a aba "Security" do GitHub.
      - name: Upload do resultado SARIF do Dependency-Check para GitHub Security
        if: always() # Garante que o upload ocorra mesmo se o step anterior falhar
        uses: github/codeql-action/upload-sarif@v3
        with:
          sarif_file: dependency-check-results.sarif
          category: sca-juiceshop # Categoria para agrupar alertas no GitHub

  # =====================================================================================
  # ETAPA 4: SCAN DE SEGREDOS
  # Objetivo: Verificar se há segredos (senhas, chaves de API, tokens) commitados
  # acidentalmente no código-fonte, INCLUINDO O HISTÓRICO COMPLETO.
  # Ferramenta: Gitleaks
  # =====================================================================================
  secrets-scan:
    name: Varredura de Segredos com Gitleaks
    runs-on: ubuntu-latest
    permissions:
      contents: read # Necessário para o checkout
      security-events: write # Necessário para fazer upload do SARIF para a aba Security
      actions: read # Para que a action Gitleaks possa usar o GITHUB_TOKEN
    steps:
      # Passo 4.1: Baixar o código-fonte do OWASP Juice Shop COM HISTÓRICO COMPLETO.
      # fetch-depth: 0 é crucial para que o Gitleaks possa analisar todo o histórico de commits.
      - name: Checkout do código Juice Shop (com histórico completo)
        uses: actions/checkout@v4
        with:
           fetch-depth: 0 # Crucial para Gitleaks analisar todo o histórico do fork

      # Passo 4.2: Executar Gitleaks.
      # A action gitleaks/gitleaks-action@v2 gerará um relatório SARIF.
      # Vamos usar variáveis de ambiente para controlar o nome e formato do relatório.
      - name: Executar Gitleaks
        uses: gitleaks/gitleaks-action@v2
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }} # Necessário para a action interagir com a API do GitHub (ex: reports enriquecidos)
          GITLEAKS_ENABLE_UPLOAD_ARTIFACT: "false" # DESABILITAMOS o upload automático pela action para ter mais controle
          GITLEAKS_REPORT_FORMAT: "sarif"          # Definimos explicitamente o formato
          GITLEAKS_EXIT_CODE: "0"                  # Para fins didáticos, não falha o build se segredos forem encontrados

      # Passo 4.3: Renomear o relatório gerado pelo Gitleaks para um nome padronizado
      # A action gitleaks/gitleaks-action@v2 por padrão parece gerar 'results.sarif' no diretório raiz
      # ou 'gitleaks-report.sarif' dependendo da versão/configuração interna.
      # Verificaremos se um dos nomes comuns existe e o renomearemos/moveremos.
      # Se o arquivo não existir, o step falhará, o que é bom para depuração.
      - name: Localizar e Renomear Relatório Gitleaks para 'gitleaks-report.sarif'
        run: |
          if [ -f "results.sarif" ]; then
            echo "Arquivo results.sarif encontrado, renomeando para gitleaks-report.sarif"
            mv results.sarif gitleaks-report.sarif
          elif [ -f "gitleaks-report.sarif" ]; then
            echo "Arquivo gitleaks-report.sarif já existe com o nome correto."
          else
            echo "::error::Nenhum arquivo de relatório SARIF (results.sarif ou gitleaks-report.sarif) gerado pelo Gitleaks foi encontrado."
            exit 1
          fi
        # Adicionar continue-on-error: true se quiser que o workflow continue mesmo se o arquivo não for encontrado,
        # mas para didática, falhar aqui pode ser mais instrutivo.
        # Para este laboratório, como GITLEAKS_EXIT_CODE é 0 e não esperamos leaks, o arquivo pode estar vazio,
        # mas ainda deve ser criado.

      # Passo 4.4: Enviar o relatório SARIF do Gitleaks para a aba "Security" -> "Code scanning alerts" do GitHub.
      # Fazer upload do relatório SARIF do Gitleaks (agora com nome padronizado) como artefato.
      - name: Upload do relatório SARIF do Gitleaks (Artefato)
        uses: actions/upload-artifact@v4
        with:
          name: Gitleaks-Scan-Results
          path: gitleaks-report.sarif
          if-no-files-found: error # Falha o step se o arquivo não for encontrado após a renomeação

      # Passo 4.5: Enviar o relatório SARIF do Gitleaks para a aba "Security" do GitHub.
      - name: Upload do resultado SARIF do Gitleaks para GitHub Security
        if: always() # Tenta fazer o upload mesmo que o Gitleaks tenha encontrado algo (já que GITLEAKS_EXIT_CODE é 0)
        uses: github/codeql-action/upload-sarif@v3
        with:
          sarif_file: gitleaks-report.sarif # Caminho para o arquivo SARIF gerado
          category: gitleaks-juiceshop # Categoria para agrupar os alertas na aba Security    

  # =====================================================================================
  # ETAPA 5: SCAN DE IMAGEM DE CONTAINER
  # Objetivo: Analisar uma imagem Docker (neste caso, a oficial do Juice Shop)
  # em busca de vulnerabilidades conhecidas em seus pacotes de sistema operacional e bibliotecas.
  # Ferramenta: Trivy
  # =====================================================================================
  scan-official-juice-shop-image:
    name: Scan da Imagem Docker Oficial do Juice Shop com Trivy
    runs-on: ubuntu-latest
    permissions:
      security-events: write # Para Trivy (via upload-sarif) enviar resultados para a aba Security
    steps:
      # Passo 5.1: Checkout do código (apenas para ter acesso ao workflow em si, se necessário para alguma lógica, aqui é mais pro forma)
      - name: Checkout do código (apenas para contexto do workflow)
        uses: actions/checkout@v4

      # Passo 5.2: Scan da imagem Docker oficial do Juice Shop usando a action do Trivy.
      # severity: 'CRITICAL,HIGH' foca nos problemas mais graves.
      # ignore-unfixed: true evita falhas por vulnerabilidades que ainda não têm correção oficial.
      # exit-code: '0' é para fins didáticos, para não falhar o build. Em produção, poderia ser '1' para falhar.
      - name: Scan da Imagem Docker Oficial com Trivy
        uses: aquasecurity/trivy-action@0.30.0 # Verifique a versão mais recente da action
        with:
          image-ref: 'bkimminich/juice-shop:latest' # Imagem oficial do Juice Shop no Docker Hub
          format: 'sarif' # Formato de saída para integração com GitHub
          output: 'trivy-juiceshop-official-results.sarif' # Nome do arquivo de resultados
          severity: 'CRITICAL,HIGH' # Níveis de severidade a serem reportados
          ignore-unfixed: true # Não falhar se houver vulnerabilidades sem correção disponível
          exit-code: '0' # Não falhar o build se vulnerabilidades forem encontradas (para fins didáticos)
            
      # Passo 5.3: Fazer upload do relatório SARIF do Trivy como artefato.
      - name: Upload do relatório SARIF do Trivy (Artefato)
        uses: actions/upload-artifact@v4
        with:
          name: Trivy-ImageScan-Results
          path: trivy-juiceshop-official-results.sarif

      # Passo 5.4: Enviar o relatório SARIF do Trivy para a aba "Security" do GitHub.
      - name: Upload do resultado SARIF do Trivy (Imagem Oficial) para GitHub Security
        if: always()
        uses: github/codeql-action/upload-sarif@v3
        with:
          sarif_file: 'trivy-juiceshop-official-results.sarif'
          category: trivy-juiceshop-image # Categoria para agrupar alertas

  # =====================================================================================
  # ETAPA 6: ANÁLISE DINÂMICA DE SEGURANÇA DE APLICAÇÃO (DAST)
  # Objetivo: Testar a aplicação em execução, simulando ataques e buscando
  # vulnerabilidades que só se manifestam em runtime.
  # Ferramenta: OWASP ZAP (Baseline Scan)
  # =====================================================================================
  dast-analysis:
    name: Análise Dinâmica (DAST com ZAP no Juice Shop)
    runs-on: ubuntu-latest
    # Este job depende do Juice Shop estar rodando e acessível.
    steps:
      # Passo 6.1: Checkout do código do fork do leitor.
      # Necessário para pegar o arquivo de regras do ZAP (.zap_juiceshop_rules.tsv), se o leitor o criou.
      - name: Checkout do código (para arquivo de regras do ZAP)
        uses: actions/checkout@v4
        with:
          repository: ${{ github.repository }} # Pega o código do repositório onde o workflow está rodando (o fork do leitor)

      # Passo 6.2: Iniciar o container Docker do OWASP Juice Shop.
      # O container roda em background (-d) e expõe a porta 3000.
      # Inclui um loop para aguardar o Juice Shop iniciar antes de prosseguir.
      - name: Iniciar OWASP Juice Shop Docker container
        run: |
          docker pull bkimminich/juice-shop:latest
          docker run -d --name juice-shop-dast -p 3000:3000 bkimminich/juice-shop:latest
          echo "Aguardando Juice Shop iniciar (pode levar alguns instantes)..."
          # Loop simples para esperar o Juice Shop responder na porta 3000
          timeout 120s bash -c 'until curl -s -o /dev/null -w "%{http_code}" http://localhost:3000 | grep -q "200"; do echo -n "."; sleep 5; done'
          echo "Juice Shop iniciado!"

      # Passo 6.3: Executar o OWASP ZAP Baseline Scan.
      # Este scan é mais rápido e menos intrusivo, ideal para CI/CD.
      # cmd_options: '-j' ativa o AJAX Spider, '-T 120' aumenta o timeout do spider.
      # fail_action: false é para fins didáticos; em produção, poderia ser true.
      - name: Executar OWASP ZAP Baseline Scan no Juice Shop
        uses: zaproxy/action-baseline@v0.14.0 # Verifique a versão mais recente da action
        with:
          target: 'http://localhost:3000' # URL da aplicação rodando localmente no Docker
          rules_file_name: '.zap_juiceshop_rules.tsv' # Opcional: Arquivo de regras para ignorar alertas específicos
          cmd_options: '-j -T 120' # Habilita o AJAX Spider e define timeout para o spider
          # token: ${{ secrets.GITHUB_TOKEN }} # Opcional: Para criar issues no GitHub com os resultados
          # issue_title: 'Vulnerabilidades ZAP Encontradas no Juice Shop'
          fail_action: false # Para fins didáticos, não falhar o workflow se encontrar alertas

      # Passo 6.4: Parar e remover o container Docker do Juice Shop após o scan.
      # "if: always()" garante que este passo execute mesmo se o ZAP scan falhar.
      - name: Parar e remover o container do Juice Shop
        if: always() # Garante a limpeza mesmo se steps anteriores falharem
        run: |
          docker stop juice-shop-dast || true # "|| true" para não falhar se o container já estiver parado
          docker rm juice-shop-dast || true   # "|| true" para não falhar se o container já tiver sido removido

  # =====================================================================================
  # ETAPA 7: NOTIFICAÇÃO EM CASO DE FALHA (Exemplo Simples)
  # Objetivo: Informar se alguma das etapas críticas da pipeline falhou.
  # Este job só executa se um dos jobs listados em 'needs' tiver falhado.
  # =====================================================================================
  notify-on-failure:
    name: Notificar em Caso de Falha da Pipeline
    if: failure() # Condição para executar este job: apenas se algum job anterior falhou
    needs: [lint-files, sast-analysis, sca-analysis, secrets-scan, scan-official-juice-shop-image, dast-analysis] # Lista de jobs dos quais este depende
    runs-on: ubuntu-latest
    steps:
      # Passo 7.1: Enviar uma mensagem de erro visível nos logs da Action.
      # Em um cenário real, isso poderia ser uma notificação para Slack, e-mail, etc.
      - name: Enviar notificação de falha
        run: |
          echo "::error::ALERTA: Um ou mais jobs da pipeline DevSecOps para o Juice Shop falharam!"
          echo "Verifique os detalhes da execução na URL da Action: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"
